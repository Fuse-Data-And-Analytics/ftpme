#!/usr/bin/env python3
"""
Deployment script for the centralized FTPme file exchange platform.
This script deploys the CDK infrastructure and sets up environment variables.
"""

import os
import sys
import json
import subprocess
import boto3
from pathlib import Path

class FTPMeDeployment:
    def __init__(self):
        self.cdk_app = "infrastructure.py"
        self.stack_name = "FileExchangePlatformDev"
        
    def deploy_infrastructure(self):
        """Deploy the CDK infrastructure."""
        print("üöÄ Deploying FTPme infrastructure...")
        
        try:
            # Synthesize the CDK app first to check for errors
            print("   Synthesizing CDK app...")
            result = subprocess.run(
                ["cdk", "synth", "-a", f"python {self.cdk_app}"],
                capture_output=True,
                text=True,
                check=True
            )
            
            # Deploy the stack
            print("   Deploying stack...")
            result = subprocess.run(
                ["cdk", "deploy", "-a", f"python {self.cdk_app}", self.stack_name, "--require-approval", "never"],
                capture_output=True,
                text=True,
                check=True
            )
            
            print("‚úÖ Infrastructure deployed successfully!")
            return True
            
        except subprocess.CalledProcessError as e:
            print(f"‚ùå CDK deployment failed: {e}")
            print(f"   stdout: {e.stdout}")
            print(f"   stderr: {e.stderr}")
            return False
    
    def get_stack_outputs(self):
        """Get the stack outputs from CloudFormation."""
        print("üìã Retrieving stack outputs...")
        
        try:
            cloudformation = boto3.client('cloudformation')
            response = cloudformation.describe_stacks(StackName=self.stack_name)
            
            if not response['Stacks']:
                print(f"‚ùå Stack {self.stack_name} not found")
                return None
            
            outputs = {}
            for output in response['Stacks'][0].get('Outputs', []):
                outputs[output['OutputKey']] = output['OutputValue']
            
            print("‚úÖ Stack outputs retrieved successfully!")
            return outputs
            
        except Exception as e:
            print(f"‚ùå Failed to retrieve stack outputs: {e}")
            return None
    
    def create_env_file(self, outputs):
        """Create a .env file with the stack outputs."""
        print("üìù Creating environment configuration...")
        
        env_vars = {
            'S3_BUCKET_NAME': outputs.get('ClientFilesBucketOutput', ''),
            'TRANSFER_SERVER_ID': outputs.get('TransferServerIdOutput', ''),
            'TENANT_TABLE_NAME': outputs.get('TenantTableOutput', ''),
            'TRANSFER_SERVER_ENDPOINT': outputs.get('TransferServerEndpointOutput', ''),
            'AWS_DEFAULT_REGION': boto3.Session().region_name
        }
        
        # Write to .env file
        with open('.env', 'w') as f:
            f.write("# FTPme Platform Environment Variables\n")
            f.write("# Generated by deploy.py\n\n")
            for key, value in env_vars.items():
                f.write(f"{key}={value}\n")
        
        # Also create a shell export script
        with open('setup_env.sh', 'w') as f:
            f.write("#!/bin/bash\n")
            f.write("# FTPme Platform Environment Setup\n")
            f.write("# Source this file to set environment variables\n\n")
            for key, value in env_vars.items():
                f.write(f"export {key}='{value}'\n")
        
        # Make the shell script executable
        os.chmod('setup_env.sh', 0o755)
        
        print("‚úÖ Environment files created:")
        print("   - .env (for Python applications)")
        print("   - setup_env.sh (source this in your shell)")
        
        return env_vars
    
    def verify_deployment(self, env_vars):
        """Verify that the deployment is working correctly."""
        print("üîç Verifying deployment...")
        
        try:
            # Test S3 bucket access
            s3 = boto3.client('s3')
            bucket_name = env_vars['S3_BUCKET_NAME']
            
            try:
                s3.head_bucket(Bucket=bucket_name)
                print(f"‚úÖ S3 bucket '{bucket_name}' is accessible")
            except Exception as e:
                print(f"‚ùå S3 bucket '{bucket_name}' is not accessible: {e}")
                return False
            
            # Test DynamoDB table access
            dynamodb = boto3.client('dynamodb')
            table_name = env_vars['TENANT_TABLE_NAME']
            
            try:
                dynamodb.describe_table(TableName=table_name)
                print(f"‚úÖ DynamoDB table '{table_name}' is accessible")
            except Exception as e:
                print(f"‚ùå DynamoDB table '{table_name}' is not accessible: {e}")
                return False
            
            # Test Transfer Family server
            transfer = boto3.client('transfer')
            server_id = env_vars['TRANSFER_SERVER_ID']
            
            try:
                response = transfer.describe_server(ServerId=server_id)
                server_state = response['Server']['State']
                print(f"‚úÖ Transfer Family server '{server_id}' is in state: {server_state}")
            except Exception as e:
                print(f"‚ùå Transfer Family server '{server_id}' is not accessible: {e}")
                return False
            
            print("‚úÖ All services are accessible!")
            return True
            
        except Exception as e:
            print(f"‚ùå Verification failed: {e}")
            return False
    
    def print_next_steps(self, env_vars):
        """Print next steps for the user."""
        print("\nüéâ Deployment completed successfully!")
        print("\nüìã Next Steps:")
        print("1. Source the environment variables:")
        print("   source setup_env.sh")
        print("\n2. Or if using python-dotenv, the .env file is ready")
        print("\n3. Start the Flask application:")
        print("   python app.py")
        print("\n4. Access the web interface at: http://localhost:5000")
        print(f"\n5. SFTP server endpoint: {env_vars.get('TRANSFER_SERVER_ENDPOINT', 'N/A')}")
        print("\nüìã Architecture Summary:")
        print(f"   - Centralized S3 bucket: {env_vars['S3_BUCKET_NAME']}")
        print(f"   - Single Transfer Family server: {env_vars['TRANSFER_SERVER_ID']}")
        print(f"   - DynamoDB table: {env_vars['TENANT_TABLE_NAME']}")
        print("\nüîê Security Features:")
        print("   - Per-user IAM roles with tenant-specific S3 access")
        print("   - Logical home directory mappings")
        print("   - KMS encryption at rest")
        print("   - CloudWatch audit logging")

def main():
    print("üöÄ FTPme Centralized File Exchange Platform Deployment")
    print("=" * 60)
    
    deployment = FTPMeDeployment()
    
    # Deploy infrastructure
    if not deployment.deploy_infrastructure():
        sys.exit(1)
    
    # Get stack outputs
    outputs = deployment.get_stack_outputs()
    if not outputs:
        sys.exit(1)
    
    # Create environment files
    env_vars = deployment.create_env_file(outputs)
    
    # Verify deployment
    if not deployment.verify_deployment(env_vars):
        print("‚ö†Ô∏è  Some services may not be fully ready yet. This is normal for new deployments.")
        print("   Please wait a few minutes and try again if you encounter issues.")
    
    # Print next steps
    deployment.print_next_steps(env_vars)

if __name__ == "__main__":
    main() 